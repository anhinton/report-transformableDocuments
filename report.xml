<?xml version="1.0" encoding="UTF-8"  ?>
<?xml-stylesheet href="xsl/preview.xsl" type="text/xsl"?>
<!DOCTYPE document [
<!ENTITY mdash "&#x2014;">
<!ENTITY ndash "&#x2013;">
<!ENTITY us "_">
<!ENTITY tilde "~">
<!ENTITY bar "|">
]>
<document xmlns:xi="http://www.w3.org/2001/XInclude">
  
  <metadata>
    <title>Transforming documents with OpenAPI pipelines</title>
    <author>
      <name>Ashley Noel Hinton</name>
      <email>ahin017@aucklanduni.ac.nz</email>
    </author>
    <author>
      <name>Paul Murrell</name>
      <email>paul@stat.auckland.ac.nz</email>
    </author>
    <affiliation>Department of Statistics, The University of Auckland</affiliation>
    <date></date>
    <description>Technical report on transforming documents using an
    OpenAPI pipeline.</description>
  </metadata>

  <body>
    <section id="introduction">
      <p>Many technologies now exist for writing a document in common
      format to be transformed into various formats for sharing. This
      report proposes that using markup, rather than common markdown
      languages, is a good fit for writing flexible human- and
      machine-readable transformable documents. The examples in this
      report use OpenAPI pipelines to perform the document
      transformations into various document formats.  The pipelines
      produced show how such a task can be split into various reusable
      modules.</p>
    </section>

    <!-- end section -->

    <section>    
      <h1>A markup transformable document format</h1>

      <p>When writing reports and articles for publication in
      journals, books, online or otherwise, an author will employ one
      of many document formats to describe the typographical and
      structural details of her document. Common formats for research
      publication include the <a
      href="https://latex-project.org/">LaTeX</a> system for producing
      printed documents, and <a
      href="https://www.w3.org/html/">HTML</a> for producing online
      documents. These and other formats allow an author to have
      low-level control over a certain type of output, but usually do
      not offer control over multiple outputs.</p>

      <p>The <a href="http://pandoc.org/index.html">Pandoc</a>
      document converter is frequently used to allow an author to
      write a document in one format and then convert to another. For
      example an author could create an HTML document and use Pandoc
      to generate a LaTeX version of this document. An author will
      gnerally write a document using the Pandoc Markdown format, and
      then use Pandoc to convert the document to one (or several)
      formats for publication.</p>

      <p>Pandoc Markdown is a variant of <a
      href="https://daringfireball.net/projects/markdown/">Markdown</a>,
      a lightweight markup language written as a simpler way to author
      HTML documents. Markdown is intended to be readable without
      conversion, and as such is written so as not to appear to
      contain markup tags or formatting. While this can makes it easy
      for an author to write a document with common formatting it
      makes it very difficult to have fine-grained control over the
      eventual output document(s).</p>

      <p>As well as needing control over the appearance and structure
      of a document, an author will often need to embed software code
      to be executed to produce the final version of the
      document. Various tools exist for executing code embedded in a
      literate document to produce the desired output. For example, an
      author can embed R code in her document and use the <a
      href="http://yihui.name/knitr/">Knitr</a> package to execute the
      R code and produce a final document. An author embeds R code in
      another document format, for example HTML or LaTeX, and
      processes the document to produce an output document in the same
      format.</p>

      <p>The <a href="http://rmarkdown.rstudio.com/">R Markdown</a>
      package combines the dynamic document processing of Knitr with the
      common authoring format of Pandoc Markdown. An author can write a
      document in Pandoc Markdown which contains embedded R code to be
      executed. The author can then execute the code and produce an
      output document for publication in one of the many formats
      available through Pandoc document conversion.</p>

      <p>It is clear that a document author has many options, and the
      implementation of R Markdown in the RStudio IDE is an indication
      that many developers in the R world at least see Markdown as a
      very useful authoring tool. The following use cases will server to
      highlight some of the drawbacks to authoring in Markdown. These
      drawbacks will inform the design of a transformable document
      solution described in this report.</p>

      <p>While Markdown can be very useful for authoring simple
      documents quickly (Markdown's creators took inspiration from the
      formatting conventions of plain text emails) an author also makes
      several sacrifices in choosing Markdown over a markup language
      like HTML. An example of these limitations is the creation of
      unordered lists. In Pandoc Markdown a simple list is created by
      prepending a <q>*</q>, <q>+</q>, or <q>-</q> character to the
      beginning of each list item, as in the following example:</p>

      <pre><code>  * one
  * two
  * three</code></pre>
    
      <p>If an author wishes to create an embedded list, she must use
      the four space rule to indent each embedded list.</p>

      <pre><code>  * outer list 1
      - inner list 1
      - inner list 2
  * outer list 2</code></pre>

      <p>At even two levels this process is already quite complex. As
      list membership depends on whitespace it can be a frustrating
      exercise trying to make changes to a complex list, let alone
      author a list in the first place.</p>

      <p>In contrast, a author using HTML markup can indicate an
      unordered list using a<code>&lt;ul&gt;</code> element, which
      <code>&lt;li&gt;</code> elements for each item, as in the
      following code:</p>

      <pre><code><![CDATA[<ul>
  <li>one</li>
  <li>two</li>
  <li>three</li>
</ul>]]></code></pre>

      <p>Similarly, an embedded list simply nests the same structure
      inside a list structure, as in the following code:</p>

      <pre><code><![CDATA[<ul>
  <li>outer list 1
    <ul>
      <li>inner list 1</li>
      <li>inner list 2</li>
    </ul>
  </li>
  <li>outer list 2</li>
</ul>]]></code></pre>

      <p>The author does not have to count white space, and it is
      trivial to make changes to this list structure.</p>
  
      <p>A document author has various methods for embedding chunks of
      code in her document. For example, an author of a Knitr HTML or
      LaTeX document can enclose code chunks to be executed in
      specially formatted comments in the respective document
      languages. For example, a document author can embed and R code
      in a Knitr HTML document as in the following code:</p>

      <pre><code><![CDATA[<!-- begin.rcode
x <- rnorm(n = 10)
plot(x)
end.rcode-->]]></code></pre>

      <p>Similarly an author can embed R code in a Knitr LaTeX
      document as in the following code:</p>

      <pre><code><![CDATA[%% begin.rcode
% x <- rnorm(n = 10)
% plot(x)
%% end.rcode]]></code></pre>

      <p>A document author using the R Markdown package can enclose R
      code chunks in special <q>fenced code</q> blocks as in the
      following code:</p>

      <pre><code><![CDATA[```{r}
x <- rnorm(n = 10)
plot(x)
```]]></code></pre>

      <p>While the use of these methods for including code makes it
      quick and easy to write a document it makes it more difficult
      for an author to do extra processing to chunks of code before
      producing the a final document. In contrast, an author creating
      an HTML document might wrap R code in <code>&lt;code&gt;</code>
      elements as in the following code:</p>

      <pre><code><![CDATA[<code class="R">
  x <- rnorm(n = 10)
  plot(x)
</code>]]></code></pre>

      <p>If an author marked up code chunks in this fashion she could,
      for example, make use of tools which employ the XPATH query
      language to locate <code>&lt;code&gt;</code> elemenents and
      perform transformations. If the author gives R code chunks the
      class <q>R</q>, as in the above example, she could perform
      transformations on just the R code chunks.</p>

      <p>If an author uses Pandoc Markdown to write a document she can
      include raw HTML or raw TeX language elements to control the
      document output. These raw code sections are only processed by
      Pandoc when creating the associated output formats, and would
      otherwise be ignored. There is no simple method for creating
      custom sections or formats within Pandoc Markdown.</p>

      <p>While an author using HTML is also unable to expect new and
      custom elements to be recognised by a web browser, the fact that
      HTML is a form of XML means an author can invent her own XML
      elements for document writing. These custom elements could then be
      processed using an XML transformation tool like XSL
      Transformations to convert the custom elements to valid HTML
      code.</p>

      <p>Markdown has proven itself to be very useful for document
      authors, and it is not the suggestion of this report that a markup
      format replace Markdown entirely. Rather this report proposes that
      in situation where Markdown is not powerful enough for a document
      author a markup format like the one described in the next section
      might provide the solution. Importantly, a well designed markup
      document and transformation pipeline should allow an author to
      recover a Markdown document as <em>output</em>, thus providing a
      readable plain text document.</p>
    </section>

    <!-- end section -->

    <section>
      <h1>The <code>document</code> markup format</h1>

      <p>The transformable document format described in this report is
      an XML file with <code>document</code> as the root element. This
      document has two child elements: <code>metadata</code> and
      <code>body</code>.</p>

      <p>The <code>metadata</code> element contains the document metadata,
      with elements for the document <code>title</code> and
      <code>subtitle</code>, <code>author</code> information,
      <code>date</code> of publication, and a <code>description</code>
      section. An example <code>metadata</code> element follows:</p>

      <pre><code><xi:include href="metadataExample.xml" parse="text">
	<xi:fallback>xinclude metadataExample.html</xi:fallback>
      </xi:include></code></pre>

      <p>The <code>body</code> element contains the document's main
      content. The following elements are used in the same way as they
      are used in HTML
      (<url>https://www.w3.org/TR/html-markup/elements.html</url>):</p>

      <ul>
	<li><code>a</code> &ndash; hyperlink</li>
	<li><code>cite</code> &ndash; cited title of a work</li>
	<li><code>code</code> &ndash; code fragment</li>
	<li><code>em</code> &ndash; emphatic stress</li>
	<li><code>figcaption</code> &ndash; figure caption</li>
	<li><code>figure</code> &ndash; figure with optional caption</li>
	<li><code>h1</code> &ndash; heading</li>
	<li><code>h2</code> &ndash; heading</li>
	<li><code>h3</code> &ndash; heading</li>
	<li><code>img</code> &ndash; image</li>
	<li><code>li</code> &ndash; list item</li>
	<li><code>ol</code> &ndash; ordered list</li>
	<li><code>p</code> &ndash; paragraph</li>
	<li><code>pre</code> &ndash; preformatted text</li>
	<li><code>q</code> &ndash; quoted text</li>
	<li><code>section</code> &ndash; section</li>
	<li><code>ul</code> &ndash; unordered list</li>
      </ul>

      <p>The following custom elements are introduced in the
      <code>document</code> format:</p>

      <ul>
	<li><code>sq</code> &ndash; single quote, used to enclose a
	section of text to be quoted with single quotes.</li>
	<li><code>url</code> &ndash; URL hyperlink, used to indicate the
	enclosed URL is both the href and value of a hyperlink.</li>
      </ul>

      <p>The following code block demonstrates the use of several of the
      elements above:</p>

      <pre><code><xi:include href="elementsExample.xml" parse="text">
	<xi:fallback><todo>xinclude elementsExample.xml</todo></xi:fallback>
      </xi:include></code></pre>

      <p>The resulting output:</p>

      <xi:include href="elementsExample.xml" parse="xml">
	<xi:fallback><todo>xinclude elementsExample.xml</todo></xi:fallback>
      </xi:include>

      <p>If transformation to HTML was the only output format for my
      document there would be no need to be so explicit about the common
      HTML elements we have used. However, as I intend to also produce a
      PDF file (via LaTeX), and a Markdown file, it is important that I
      keep track of the elements which are to be transformed.</p>

      <p>To ensure that special characters are rendered correctly in
      various output formats, DTD entities are used in the
      <code>document</code> format. Working definitions of these
      entities are defined in the <code>document</code> DOCTYPE section
      to help with document authoring. These entities can then be
      replaced by language-appropriate representations in a
      transformation pipeline. The entities defined for the pipelines in
      this report are:</p>

      <ul>
	<li><code>&amp;mdash;</code> &mdash; em dash</li>
	<li><code>&amp;ndash;</code> &ndash; en dash</li>
	<li><code>&amp;us;</code> &us; underscore</li>
	<li><code>&amp;tilde;</code> &tilde; tilde</li>
	<li><code>&amp;bar;</code> &bar; bar</li>
      </ul>

      <p>The document transformation pipelines in this report allow a
      document author to execute chunks of R code using Knitr. Chunks of
      R code are wrapped in a <code>&lt;code&gt;</code> element with
      <code>class="knitr"</code>. An author can also provide a
      <code>name</code> attribute for the knitr code chunk, as well as
      knitr <code>options</code>. The following code demonstrates how to
      include an R code chunk to be executed:</p>

      <pre><code><xi:include href="knitrExample.xml" parse="text">
	<xi:fallback><todo>xinclude knitrExample.xml</todo></xi:fallback>
      </xi:include></code></pre>

      <p>And the following is the result of executing this code
      chunk:</p>

      <xi:include href="knitrExample.xml" parse="xml">
	<xi:fallback><todo>xinclude knitrExample.xml</todo></xi:fallback>
      </xi:include>

      <p>The <code>document</code> format also makes use of the
      <code>include</code> element from XInclude
      (<url>http://www.w3.org/2001/XInclude</url>) namespace to include
      XML content from external files. The inclusions of this content is
      one of the steps in the transformation pipeline.</p>

      <p>The next sections describes how OpenAPI pipelines are used to
      perform the transformation steps necessary for creating HTML, PDF,
      and Markdown output from the source document. The source document
      for this report is available at
      <url>report.xml</url>. <todo>replace with final full
      URL</todo></p>
    </section>

    <!-- end section -->

    <section>
      <h1>Using OpenAPI pipelines for transformation</h1>

      <p>The OpenAPI architecture helps to break tasks in data
      analysis down into small pieces making it easier for people to
      contribute to a data problem. The goal of the OpenAPI project is
      to make it easier for people to connect with data. Meaningful
      steps in a data workflow can be wrapped as modules. Modules can
      be arranged in pipelines, and shared to be recombined by other
      authors in their own pipelines. Pipelines and modules can be
      executed by OpenAPI glue system software. The whole project is
      open source, and open to contributions from anyone
      (<a href="http://stattech.wordpress.fos.auckland.ac.nz/2015-01-introducing-openapi/">Introducing
      OpenAPI</a>,
      <a href="http://stattech.wordpress.fos.auckland.ac.nz/2016-08-openapi-version-0-6/">OpenAPI
      version 0.6</a>).</p>

      <p>It is OpenAPI's dividing of tasks into modules which makes it
      an ideal candidate for handling document
      transformation. Transforming the <code>document</code> format
      described in the previouse section can be broken down into
      several discrete steps:</p>

      <ol>
	<li>Merge XML code indicated by <code>xi:include</code>
	elements into the document.</li>
	<li>Convert XML character entities into appropriate
	characters.</li>
	<li>Convert document into output format language.</li>
	<li>Execute embedded chunks of code.</li>
      </ol>

      <p>Several technologies already exist for handling each of these
      steps. For example, the xmllint
      (<url>http://www.xmlsoft.org/</url>) command line tool can
      replace XInclude code, and replace entities with their
      values. The xsltproc (ibid.) command line tool can be used to
      apply an XSL stylesheet to the <code>document</code> to produce
      the desired output format. The Knitr package in R can be used to
      execute chunks of R code in various document formats.</p>

      <p>What the OpenAPI architecture offers is the ability to wrap
      transformation steps in a module which takes a file as an input,
      and produces another file as an output. The output of one module
      can be passed as the intput of another module, thus building a
      pipeline which describes the entire transformation. Each module
      in an OpenAPI pipeline specifies its execution language, meaning
      an OpenAPI pipeline can have access to a wide variety of
      tools.</p>

      <p>In the following section I will descibe the modules used to
      transform a tranformable <code>document</code> file to HTML
      output, including the processing of chunks of R code. After this
      section I will show how this pipeline can be modified to produce
      PDF and Markdown output from the same source
      <code>document</code>.</p>
    </section>
	
    <section>
      <h1>Technical requirements</h1>

      <p>This is an appendix section.</p>
    </section>
  </body>
  
</document>
